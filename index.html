<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Equation Balancer (MVP 2)</title>
<style>
  :root {
    --bg: #0e0f13;
    --panel: #161922;
    --beam: #2a2f3b;
    --pan: #1f2430;
    --accent: #5ee37d;
    --warn: #ff6961;
    --text: #e8eef7;
    --muted: #a6b0c0;

    --pos-const: #4ea1ff;
    --neg-const: #ff6b6b;
    --pos-var:   #ffd166;
    --neg-var:   #8d6bff;
  }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  .app { display: grid; grid-template-rows: auto 1fr auto; height: 100%; gap: 8px; }
  header, footer { padding: 8px 12px; background: var(--panel); display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  header input[type=text] {
    flex: 1; min-width: 220px; background: #0c0e13; border: 1px solid #2c3240; border-radius: 6px; color: var(--text);
    padding: 8px 10px; font-size: 16px;
  }
  .btn {
    background: #222738; color: var(--text); border: 1px solid #394158; padding: 8px 10px; border-radius: 6px; cursor: pointer;
  }
  .btn:disabled { opacity: .5; cursor: not-allowed; }
  .toggle { border-color: #4a546f; }
  .toggle.active { outline: 2px solid var(--accent); }

  .stage { position: relative; background: linear-gradient(180deg, #101319, #0b0d12); box-shadow: inset 0 0 80px rgba(0,0,0,.5); }
  canvas { display:block; width:100%; height:100%; }

  .toolbar {
    display: grid; grid-template-columns: 1fr auto auto auto; gap: 8px; align-items: center; padding: 8px 12px; background: var(--panel);
    border-top: 1px solid #30384b;
  }

  .palette {
    display: flex; gap: 8px; align-items: center; overflow-x: auto; padding-bottom: 4px;
  }
  .block-chip {
    display:inline-flex; align-items:center; justify-content:center; min-width:48px; height:36px; padding:0 10px;
    border-radius: 6px; color:#0b0d12; font-weight:700; user-select:none; cursor:grab; border:1px solid rgba(0,0,0,.2);
    box-shadow: inset 0 0 10px rgba(255,255,255,.1), 0 4px 8px rgba(0,0,0,.35);
  }
  .pos-const { background: var(--pos-const); }
  .neg-const { background: var(--neg-const); color: #160c0c; }
  .pos-var   { background: var(--pos-var);   color: #2b2200; }
  .neg-var   { background: var(--neg-var); }

  .ops-panel { display:flex; gap:8px; align-items:center; }
  .ops-panel input[type=text] {
    width: 180px; background: #0c0e13; border: 1px solid #2c3240; border-radius: 6px; color: var(--text);
    padding: 8px 10px; font-size: 14px;
  }

  .status { display:flex; align-items:center; gap:8px; color:var(--muted); justify-self:end; }
  .led { width:10px; height:10px; border-radius:50%; background:#964; box-shadow:0 0 8px rgba(0,0,0,.6) inset; }
  .led.on { background: var(--accent); box-shadow: 0 0 6px var(--accent); }
</style>
</head>
<body>
<div class="app">
  <header>
    <button id="lockBtn" class="btn toggle">ðŸ”’ Locked</button>
    <input id="eqInput" type="text" value="2x + 4 = 3x - 1" />
    <button id="applyEqBtn" class="btn">Apply</button>
    <button id="rebalanceBtn" class="btn">Rebalance</button>
    <div class="status">
      <span>Balanced</span>
      <span id="led" class="led"></span>
    </div>
  </header>

  <div id="stage" class="stage">
    <canvas id="world"></canvas>
  </div>

  <div class="toolbar">
    <!-- Palette (drag to pans) -->
    <div class="palette" title="Drag onto a pan">
      <div class="block-chip pos-const" draggable="true" data-kind="const" data-val="+1">+1</div>
      <div class="block-chip neg-const" draggable="true" data-kind="const" data-val="-1">-1</div>
      <div class="block-chip pos-var" draggable="true" data-kind="x" data-pow="1" data-val="+1">+x</div>
      <div class="block-chip neg-var" draggable="true" data-kind="x" data-pow="1" data-val="-1">-x</div>
      <!-- You can add more chips later; typed operators handle powers/reciprocals -->
    </div>

    <!-- Quick ops -->
    <div class="ops-panel">
      <button class="btn" id="add1">+1</button>
      <button class="btn" id="sub1">-1</button>
      <button class="btn" id="addx">+x</button>
      <button class="btn" id="subx">-x</button>
    </div>

    <!-- Typed operator (works only when Locked) -->
    <div class="ops-panel">
      <input id="opInput" type="text" placeholder="Op: +3, -x^2, *2, /3, *1/2" />
      <button id="applyOpBtn" class="btn">Apply Op</button>
    </div>

    <div class="ops-panel" style="justify-self:end;">
      <button class="btn" id="undo">Undo</button>
      <button class="btn" id="redo">Redo</button>
      <button class="btn" id="reset">Reset</button>
    </div>
  </div>

  <footer>
    <span style="color:var(--muted)">Tip: Unlock to edit the equation. Lock to manipulate blocks/operators. Operators: +n, -n, Â±x^k, Â±1/x^k, *k, /k.</span>
  </footer>
</div>

<!-- Matter.js CDN -->
https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js
<script>
(() => {
  // ======= Utilities: Rational arithmetic =======
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
  function norm(r){ if (r.den<0){ r.den*=-1; r.num*=-1; } if (r.num===0){ r.den=1; } const g = gcd(r.num, r.den); r.num/=g; r.den/=g; return r; }
  const R = (num, den=1) => norm({num,den});
  const Radd=(a,b)=>norm({num:a.num*b.den + b.num*a.den, den:a.den*b.den});
  const Rsub=(a,b)=>norm({num:a.num*b.den - b.num*a.den, den:a.den*b.den});
  const Rmul=(a,b)=>norm({num:a.num*b.num, den:a.den*b.den});
  const Rdiv=(a,b)=>{ if(b.num===0) throw new Error('Divide by zero'); return norm({num:a.num*b.den, den:a.den*b.num}); };
  const Rcmp=(a,b)=> (a.num*b.den - b.num*a.den);
  const Rabs=a=>R(Math.abs(a.num), a.den);
  const RisZero=a=>a.num===0;
  const RtoStr=a=>{
    if (a.den===1) return String(a.num);
    return `${a.num}/${a.den}`;
  };
  const Rfloor=a=>{
    const n = Math.trunc(a.num / a.den);
    return n;
  };
  const Rfrac=a=>R(a.num - Rfloor(a)*a.den, a.den);

  // ======= Types =======
  // Powers allowed
  const POWERS = [-2,-1,0,1,2,3,4,5]; // 0 = constants
  const isPow = p => POWERS.includes(p);

  // Equation state: net rational per power per side
  function emptySide(){
    const m={}; for (const p of POWERS) m[p]=R(0,1); return m;
  }
  let state = {
    locked: true,
    blockLimitPerSide: 24,
    eq: { left: emptySide(), right: emptySide() },
    history: [],
    future: []
  };

  const byId=id=>document.getElementById(id);
  const led = byId('led');
  const lockBtn = byId('lockBtn');
  const eqInput = byId('eqInput');
  const applyEqBtn = byId('applyEqBtn');
  const rebalanceBtn = byId('rebalanceBtn');
  const add1Btn = byId('add1'), sub1Btn = byId('sub1'), addxBtn = byId('addx'), subxBtn = byId('subx');
  const undoBtn = byId('undo'), redoBtn = byId('redo'), resetBtn = byId('reset');
  const opInput = byId('opInput'), applyOpBtn = byId('applyOpBtn');

  // ======= Physics (Matter.js) =======
  const { Engine, Render, World, Bodies, Body, Constraint, Mouse, MouseConstraint } = Matter;
  const stage = byId('stage');
  const canvas = byId('world');
  const engine = Engine.create({ gravity: { x: 0, y: 1 }});
  const render = Render.create({
    canvas,
    engine,
    options: { background: 'transparent', wireframes: false, pixelRatio: window.devicePixelRatio || 1 }
  });

  let beam, fulcrum, panLeft, panRight, constraintLeft, constraintRight;
  const PAN_W=260, PAN_H=20, BEAM_W=720, BEAM_H=16, SNAP=40;

  const blocks = new Map(); // id -> body
  let nextBlockId = 1;

  function resetWorld(pushHistory=true){
    World.clear(engine.world, false);
    engine.world.bodies = [];
    engine.world.constraints = [];

    const W = stage.clientWidth, H = stage.clientHeight;
    render.canvas.width = W * (window.devicePixelRatio||1);
    render.canvas.height= H * (window.devicePixelRatio||1);
    render.canvas.style.width = W + 'px';
    render.canvas.style.height= H + 'px';

    const centerX = W/2, centerY = H/2 + 40;

    const floor = Bodies.rectangle(W/2, H+50, W*2, 100, { isStatic: true, render: { visible: false }});
    World.add(engine.world, floor);

    fulcrum = Bodies.rectangle(centerX, centerY, 20, 20, { isStatic:true, render:{ fillStyle:'#111' }});
    beam = Bodies.rectangle(centerX, centerY, BEAM_W, BEAM_H, { chamfer:{radius:8}, render:{ fillStyle:getCSS('--beam') }});

    const panY = centerY + 60;
    const leftX = centerX - BEAM_W/2 + 80;
    const rightX= centerX + BEAM_W/2 - 80;
    panLeft = Bodies.rectangle(leftX, panY, PAN_W, PAN_H, { render:{ fillStyle:getCSS('--pan') } });
    panRight= Bodies.rectangle(rightX, panY, PAN_W, PAN_H, { render:{ fillStyle:getCSS('--pan') } });

    const pivot = Constraint.create({ bodyA: fulcrum, bodyB: beam, stiffness:1, length:0 });
    constraintLeft = Constraint.create({ bodyA: beam, pointA:{x:-BEAM_W/2+80,y:10}, bodyB: panLeft, stiffness:1, length:0 });
    constraintRight= Constraint.create({ bodyA: beam, pointA:{x: BEAM_W/2-80,y:10}, bodyB: panRight, stiffness:1, length:0 });

    World.add(engine.world, [fulcrum, beam, panLeft, panRight, pivot, constraintLeft, constraintRight]);

    const mouse = Mouse.create(render.canvas);
    const mc = MouseConstraint.create(engine, { mouse, constraint:{ stiffness:.2, render:{visible:false} }});
    World.add(engine.world, mc);

    if (pushHistory) pushHistorySnapshot();
  }

  function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName); }

  function pushHistorySnapshot(){
    state.history.push(JSON.stringify(state.eq));
    state.future = [];
    updateUndoRedoButtons();
  }
  function undo(){
    if (!state.history.length) return;
    state.future.push(JSON.stringify(state.eq));
    state.eq = JSON.parse(state.history.pop());
    syncBlocksFromState(true);
    updateUndoRedoButtons();
  }
  function redo(){
    if (!state.future.length) return;
    state.history.push(JSON.stringify(state.eq));
    state.eq = JSON.parse(state.future.pop());
    syncBlocksFromState(true);
    updateUndoRedoButtons();
  }
  function updateUndoRedoButtons(){
    undoBtn.disabled = state.history.length===0;
    redoBtn.disabled = state.future.length===0;
  }

  // ======= Equation parsing/formatting =======
  // Accepts: +/- a (int) OR +/- a x^k, k in [-2,-1,1..5], also 1/x^k
  function parseEquation(str){
    const parts = str.split('=');
    if (parts.length!==2) throw new Error('Equation must contain exactly one "=".');
    return { left: parseSide(parts[0]), right: parseSide(parts[1]) };
  }
  function parseSide(s){
    const side = emptySide();
    s = s.replace(/\s+/g,'');
    if (!s) return side;
    // ensure leading sign
    if (!/^[+\-]/.test(s)) s = '+' + s;

    // Tokenize Â±term
    let i=0;
    while(i < s.length){
      let sign = 1;
      if (s[i]==='+'){ sign=1; i++; }
      else if (s[i]==='-'){ sign=-1; i++; }

      // Possible multiplicative coefficient (integer or a/b)
      // Format: [num[/den]] optionally before variable
      const coefStart=i;
      while (i<s.length && /[0-9/]/.test(s[i])) i++;
      let coefStr = s.slice(coefStart, i);
      if (coefStr==='' && s[i]==='x'){ /* empty -> 1 */ }
      else if (coefStr==='' && (i>=s.length || s[i]!=='x')) { coefStr='1'; }
      let coef = parseRationalStrict(coefStr || '1'); // '1', '2/3', '5' okay

      let power = 0;
      if (s[i]==='x' || s[i]==='X'){
        i++;
        // power forms: ^k OR negative exponent via ^-k OR reciprocal forms "^-1", "^-2"
        if (s[i]==='^'){
          i++;
          const pStart=i;
          while (i<s.length && /[\-\d]/.test(s[i])) i++;
          const pStr = s.slice(pStart, i);
          const p = parseInt(pStr, 10);
          if (!isPow(p) || p===0) throw new Error(`Power x^${p} not supported`);
          power = p;
        } else {
          power = 1;
        }
      } else if (s[i]==='/' && s[i+1]==='x'){
        // form: 1/x or a/x^k
        i+=2;
        // optional ^k
        let k=1;
        if (s[i]==='^'){ i++; const ps=i; while(i<s.length && /[\-\d]/.test(s[i])) i++; k=parseInt(s.slice(ps,i),10); }
        if (!isPow(-Math.abs(k))) throw new Error(`Power 1/x^${k} unsupported`);
        power = -Math.abs(k);
      } else {
        power = 0; // constant
      }

      // Apply sign
      if (sign<0) coef = Rmul(coef, R(-1,1));
      // Accumulate
      side[power] = Radd(side[power], coef);
    }
    // Normalize (keep as net)
    return side;
  }

  function parseRationalStrict(s){
    if (!s) return R(1,1);
    if (/^\d+$/.test(s)) return R(parseInt(s,10),1);
    if (/^\d+\/\d+$/.test(s)){
      const [a,b] = s.split('/').map(n=>parseInt(n,10));
      return R(a,b);
    }
    throw new Error(`Invalid number "${s}"`);
  }

  function formatSide(side){
    // Canonical: x^5 .. x^2, x, 1/x, 1/x^2, constants
    const order = [5,4,3,2,1,-1,-2,0];
    const parts = [];
    for (const p of order){
      const v = side[p];
      if (RisZero(v)) continue;
      const sign = v.num<0 ? '-' : '+';
      const a = Rabs(v);
      const coefStr = (a.den===1 && a.num===1 && p!==0) ? '' : RtoStr(a);
      let term='';
      if (p===0){
        term = coefStr || '1';
      } else if (p>0){
        term = `${coefStr}x${p===1?'':`^${p}`}`;
      } else {
        const k = Math.abs(p);
        term = `${coefStr}${coefStr? ' ' : ''}1/x${k===1?'':`^${k}`}`.trim();
      }
      parts.push(sign + term);
    }
    if (parts.length===0) return '0';
    let s = parts.join('');
    if (s[0]==='+') s = s.slice(1);
    return s.replace(/\+/g,' + ').replace(/\-/g,' - ');
  }
  function formatEquation(eq){ return `${formatSide(eq.left)} = ${formatSide(eq.right)}`; }

  // ======= Operators =======
  // Accept: +n, -n, Â±x^k, Â±1/x^k, *k, /k
  function parseOperator(s){
    s = s.trim().replace(/\s+/g,'');
    if (!s) throw new Error('Empty operator');

    const first = s[0];
    if (first==='+' || first==='-'){
      // term add
      return { type:'add', term: parseSide(first + s.slice(1)) }; // reuse side parser for single term
    }
    if (first==='*' || first==='Ã—'){
      const k = parseRationalStrict(s.slice(1));
      return { type:'mul', k };
    }
    if (first==='/' || first==='Ã·'){
      const k = parseRationalStrict(s.slice(1));
      if (k.num===0) throw new Error('Divide by zero');
      return { type:'mul', k: R(k.den, k.num) }; // multiply by reciprocal
    }
    throw new Error('Unsupported operator. Use +n, -n, Â±x^k, Â±1/x^k, *k, /k');
  }

  function applyOperator(op){
    // mutate eq on both sides
    if (op.type==='add'){
      for (const p of POWERS){
        state.eq.left[p]  = Radd(state.eq.left[p],  op.term[p]||R(0,1));
        state.eq.right[p] = Radd(state.eq.right[p], op.term[p]||R(0,1));
      }
    } else if (op.type==='mul'){
      for (const p of POWERS){
        state.eq.left[p]  = Rmul(state.eq.left[p],  op.k);
        state.eq.right[p] = Rmul(state.eq.right[p], op.k);
      }
    }
    // Reduce opposing signs on same side (cancellation)
    canonicalizeState();
    pushHistorySnapshot();
    syncBlocksFromState(true);
  }

  function canonicalizeState(){
    // Nothing special needed; we store nets. This inherently cancels pos/neg.
    // (We could later preserve "piles" visually; for now nets are fine.)
  }

  // ======= Blocks <-> State =======
  function countsFromBlocks(){
    const left = emptySide(), right = emptySide();
    for (const [,b] of blocks){
      const side = whichPan(b);
      if (!side) continue;
      const p = b.plugin.power;
      const v = b.plugin.value; // Rational, signed
      if (side==='left')  left[p]  = Radd(left[p],  v);
      if (side==='right') right[p] = Radd(right[p], v);
    }
    return { left, right };
  }

  function syncBlocksFromState(skipHistory=false){
    // Clear blocks and respawn minimal set
    for (const [,b] of blocks){ World.remove(engine.world, b); }
    blocks.clear();

    spawnFromSide(panLeft, state.eq.left);
    spawnFromSide(panRight, state.eq.right);
    layoutBlocksOnPans();
    eqInput.value = formatEquation(state.eq);
    if (!skipHistory) pushHistorySnapshot();
    updateBalanceLED();
  }

  function spawnFromSide(pan, sideMap){
    // For each power, split net value into integer + remainder
    for (const p of POWERS){
      const v = sideMap[p];
      if (RisZero(v)) continue;
      const sign = v.num<0 ? -1 : 1;
      const a = Rabs(v);
      // integer part
      const n = Rfloor(a);
      for (let i=0;i<n;i++){
        spawnBlock(pan, p, R(sign,1)); // Â±1 unit
      }
      // fractional remainder
      const r = Rfrac(a);
      if (!RisZero(r)){
        spawnBlock(pan, p, R(sign*r.num, r.den));
      }
    }
  }

  function spawnBlock(targetPan, power, valueR){
    // power: 0=const, Â± for vars
    const isVar = power !== 0;
    const sign = valueR.num<0?-1:1;
    const color = isVar
      ? (sign>0?getCSS('--pos-var'):getCSS('--neg-var'))
      : (sign>0?getCSS('--pos-const'):getCSS('--neg-const'));

    // block limit per side
    const totals = countBlocksOnSide(targetPan);
    if (totals >= state.blockLimitPerSide) return;

    const w=46, h=30;
    const x = targetPan.position.x + (Math.random()*80-40);
    const y = targetPan.position.y - 60;

    const body = Bodies.rectangle(x, y, w, h, {
      chamfer: { radius: 6 },
      render: {
        fillStyle: color,
        strokeStyle: '#00000055',
        lineWidth: 1,
        sprite: undefined
      }
    });
    body.plugin = {
      power,
      value: valueR // Rational signed
    };
    World.add(engine.world, body);
    blocks.set(nextBlockId++, body);
    return body;
  }

  function countBlocksOnSide(pan){
    let c=0;
    for (const [,b] of blocks){
      const side = whichPan(b);
      if (side && ((side==='left' && pan===panLeft) || (side==='right' && pan===panRight))) c++;
    }
    return c;
  }

  function layoutBlocksOnPans(){
    const grid = (pan) => {
      const bodies = [...blocks.values()].filter(b => whichPan(b) && ((whichPan(b)==='left' && pan===panLeft) || (whichPan(b)==='right' && pan===panRight)));

      // Group by (power, sign, isVar) so like terms cluster
      const keyOf = b => {
        const p=b.plugin.power, v=b.plugin.value.num<0?-1:1, t=(p===0?'c':'v');
        return `${p}:${v}:${t}`;
      };
      const groups = {};
      for (const b of bodies) (groups[keyOf(b)] ||= []).push(b);
      const keys = Object.keys(groups).sort((a,b)=> {
        // order: var high powers, then reciprocals, then constants
        const pa=parseInt(a.split(':')[0],10), pb=parseInt(b.split(':')[0],10);
        const ord = (pb-pa); // higher first
        if (ord!==0) return ord;
        return a.localeCompare(b);
      });

      const cols = Math.max(1, Math.floor(PAN_W / SNAP));
      const leftX = pan.position.x - (cols-1)*SNAP/2;

      let i=0;
      for (const k of keys){
        for (const b of groups[k]){
          const col = i % cols;
          const row = Math.floor(i / cols);
          const gx = leftX + col*SNAP;
          const gy = pan.position.y - 24 - row*SNAP;
          Body.setPosition(b, { x: gx, y: gy });
          Body.setAngle(b, 0);
          Body.setVelocity(b, { x:0, y:0 });
          Body.setAngularVelocity(b, 0);
          i++;
        }
      }
    };
    grid(panLeft); grid(panRight);
  }

  function whichPan(b){
    const isOn = (pan)=>{
      const px=pan.position.x, py=pan.position.y;
      const bx=b.position.x, by=b.position.y;
      return Math.abs(bx-px) <= PAN_W/2 && by < py && by > py - 90;
    };
    if (isOn(panLeft)) return 'left';
    if (isOn(panRight)) return 'right';
    return null;
  }

  // ======= Rendering labels & tilt =======
  // Draw labels after render
  Matter.Events.on(render, 'afterRender', () => {
    const ctx = render.context; ctx.save();
    ctx.font = 'bold 12px system-ui, Segoe UI, Roboto, sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    for (const [,b] of blocks){
      const { x, y } = b.position;
      const p = b.plugin.power;
      const v = b.plugin.value;
      const isVar = p!==0;
      const signChar = v.num<0?'-':'';
      const a = Rabs(v);
      let label = '';
      const coefStr = (a.den===1 && a.num===1 && isVar) ? '' : RtoStr(a);
      if (isVar){
        if (p>0) label = `${signChar}${coefStr}${coefStr? ' ':''}x${p===1?'':`^${p}`}`;
        else label = `${signChar}${coefStr}${coefStr?' ':''}1/x${Math.abs(p)===1?'':`^${Math.abs(p)}`}`;
      } else {
        label = `${signChar}${RtoStr(a)}`;
      }
      // text color depending on bg brightness
      ctx.fillStyle = '#0a0a0a';
      ctx.fillText(label, x, y);
    }
    ctx.restore();
  });

  // Tilt based on algebraic mismatch
  Matter.Events.on(engine, 'afterUpdate', () => {
    const eq = countsFromBlocks();
    // Sum mismatch across all powers, weight = 1
    let mismatchNum = 0;
    for (const p of POWERS){
      const diff = Rsub(eq.left[p], eq.right[p]);
      // approximate mismatch as signed fraction value (num/den)
      mismatchNum += diff.num / diff.den;
    }
    const targetAngle = clamp(mismatchNum * 0.03, -0.35, 0.35);
    const current = beam.angle;
    const next = current + (targetAngle - current) * 0.12;
    Body.setAngle(beam, next);

    updateBalanceLED();
  });

  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
  function updateBalanceLED(){
    const eq = countsFromBlocks();
    let balanced = true;
    for (const p of POWERS){
      if (Rcmp(eq.left[p], eq.right[p])!==0){ balanced=false; break; }
    }
    led.classList.toggle('on', balanced);
  }

  // ======= UI wiring =======
  function setEquationFromInput(){
    if (state.locked) return;
    try {
      const parsed = parseEquation(eqInput.value);
      state.eq = parsed;
      pushHistorySnapshot();
      syncBlocksFromState(true);
    } catch(e){ alert('Parse error: ' + e.message); }
  }
  function rebalanceFromBlocks(){
    state.eq = countsFromBlocks();
    pushHistorySnapshot();
    eqInput.value = formatEquation(state.eq);
    updateBalanceLED();
  }

  // palette drag
  const paletteItems = document.querySelectorAll('.block-chip');
  paletteItems.forEach(el=>{
    el.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', JSON.stringify({
        kind: el.dataset.kind, pow: parseInt(el.dataset.pow||'0',10), val: el.dataset.val
      }));
    });
  });
  stage.addEventListener('dragover', e => e.preventDefault());
  stage.addEventListener('drop', e => {
    e.preventDefault();
    const data = JSON.parse(e.dataTransfer.getData('text/plain')||'{}');
    if (!data.kind) return;
    const rect = stage.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const sidePan = (Math.abs(x - panLeft.position.x) < Math.abs(x - panRight.position.x)) ? panLeft : panRight;
    // Build a term and add to that side (blocks authoritative)
    const power = data.kind==='x' ? (data.pow||1) : 0;
    const value = R(parseInt(data.val,10), 1);
    // Update state (adds to one side only, not both)
    const eqNow = countsFromBlocks();
    if (sidePan===panLeft) eqNow.left[power] = Radd(eqNow.left[power], value);
    else eqNow.right[power] = Radd(eqNow.right[power], value);
    state.eq = eqNow;
    pushHistorySnapshot();
    syncBlocksFromState(true);
  });

  lockBtn.addEventListener('click', ()=>{
    state.locked = !state.locked;
    lockBtn.classList.toggle('active', state.locked);
    lockBtn.textContent = state.locked ? 'ðŸ”’ Locked' : 'ðŸ”“ Unlocked';
    eqInput.disabled = state.locked;
    applyEqBtn.disabled = state.locked;
    opInput.disabled = !state.locked;
    applyOpBtn.disabled = !state.locked;
  });
  applyEqBtn.addEventListener('click', setEquationFromInput);
  rebalanceBtn.addEventListener('click', rebalanceFromBlocks);

  // quick ops (both sides), only when locked (blocks authoritative)
  function bothSidesAdd(power, amount){
    state.eq.left[power]  = Radd(state.eq.left[power],  R(amount,1));
    state.eq.right[power] = Radd(state.eq.right[power], R(amount,1));
    pushHistorySnapshot();
    syncBlocksFromState(true);
  }
  add1Btn.addEventListener('click', ()=> state.locked && bothSidesAdd(0, +1));
  sub1Btn.addEventListener('click', ()=> state.locked && bothSidesAdd(0, -1));
  addxBtn.addEventListener('click', ()=> state.locked && bothSidesAdd(1, +1));
  subxBtn.addEventListener('click', ()=> state.locked && bothSidesAdd(1, -1));

  // typed operator
  applyOpBtn.addEventListener('click', ()=>{
    if (!state.locked) return;
    try {
      const op = parseOperator(opInput.value);
      applyOperator(op);
      opInput.value='';
    } catch(e){ alert('Operator error: ' + e.message); }
  });

  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);
  resetBtn.addEventListener('click', ()=>{
    state = { locked:true, blockLimitPerSide:24, eq:{ left:emptySide(), right:emptySide() }, history:[], future:[] };
    resetWorld(false);
    eqInput.value = '2x + 4 = 3x - 1';
    try { state.eq = parseEquation(eqInput.value); } catch {}
    syncBlocksFromState();
  });

  window.addEventListener('resize', ()=>{ resetWorld(false); syncBlocksFromState(); });

  // ======= Init =======
  resetWorld(false);
  try { state.eq = parseEquation(eqInput.value); } catch {}
  syncBlocksFromState();
  opInput.disabled = !state.locked; applyOpBtn.disabled = !state.locked;

  Engine.run(engine); Render.run(render);
})();
</script>
</body>
</html>
